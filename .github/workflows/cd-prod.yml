name: CD - Deploy to Prod

on:
  push:
    branches: [ "main" ]
    tags: [ 'v*' ]

env:
  AWS_REGION: eu-west-1
  # Source Repo (Dev)
  ECR_REPOSITORY_DEV: user-ip-viewer-combined-dev
  # Target Repo (Production)
  ECR_REPOSITORY_PROD: user-ip-viewer-combined

jobs:
  build-and-deploy-prod:
    runs-on: ubuntu-latest
    environment: production
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Needed to track merge parents

      - name: Configure AWS Credentials (Prod OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # TODO: ideally use a separate Prod role. for now using the same account/role structure as a demo 
          role-to-assume: arn:aws:iam::343253677111:role/github-actions-user-ip-viewer-dev 
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      # Ensure Prod Repo Exists
      - name: Ensure ECR Repo Exists
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_PROD }} || aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY_PROD }}

      - name: Determine Source SHA
        id: source-sha
        run: |
          # If this is a merge commit, the second parent is usually the source (dev)
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "Current Commit: $COMMIT_SHA"
          
          # HACK for Demo: We will try to find the dev tag corresponding to the second parent.
          PARENTS=$(git show -s --format=%P HEAD)
          if [ $(echo $PARENTS | wc -w) -gt 1 ]; then
             SOURCE_SHA=$(echo $PARENTS | awk '{print $2}')
             echo "Detected Merge Commit. Source Logic SHA: $SOURCE_SHA"
          else
             SOURCE_SHA=$COMMIT_SHA
             echo "Detected Direct Push. Source Logic SHA: $SOURCE_SHA"
          fi
          
          echo "source_tag=dev-$SOURCE_SHA" >> $GITHUB_OUTPUT

      - name: Promote Combined Image (No Rebuild)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          SOURCE_TAG: ${{ steps.source-sha.outputs.source_tag }}
        run: |
          echo "Promoting artifacts from $SOURCE_TAG to latest..."
          
          # Strict Check: Pull the verified DEV image
          # If this fails, it means we don't have a verified artifact -> Fail Pipeline
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY_DEV:$SOURCE_TAG
          
          # Retag Latest
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_DEV:$SOURCE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_PROD:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_PROD:latest
          
          # Retag SHA (Always useful)
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_DEV:$SOURCE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_PROD:${{ github.sha }}
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_PROD:${{ github.sha }}

          # Retag Semantic Version (if applicable)
          if [ "${{ github.ref_type }}" == "tag" ]; then
            VERSION_TAG=${{ github.ref_name }}
            echo "Applying Semantic Version Tag: $VERSION_TAG"
            docker tag $ECR_REGISTRY/$ECR_REPOSITORY_DEV:$SOURCE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_PROD:$VERSION_TAG
            docker push $ECR_REGISTRY/$ECR_REPOSITORY_PROD:$VERSION_TAG
          fi
